<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>lib.annotations API documentation</title>
<meta name="description" content="Annotation data structure …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.annotations</code></h1>
</header>
<section id="section-intro">
<h2 id="annotation-data-structure">Annotation data structure</h2>
<p>Annotations are stored in layers. Each layer consists in annotation of the same class (as defined by <code><a title="lib.classes.AnnotationClass" href="classes/index.html#lib.classes.AnnotationClass">AnnotationClass</a></code>),
made of labelled bounding boxes <code><a title="lib.misc.bounding_box.LabelledBBX" href="misc/bounding_box.html#lib.misc.bounding_box.LabelledBBX">LabelledBBX</a></code>.</p>
<p>Example: adding 4 boxes and merging boxes of the same group using <code><a title="lib.annotations.AnnotationLayer.reduce" href="#lib.annotations.AnnotationLayer.reduce">AnnotationLayer.reduce()</a></code>.</p>
<pre><code>ann = AnnotationLayer(location=&quot;/tmp/test.json&quot;)
ann.add_box(LabelledBBX(&quot;header&quot;, 0, 1, 10, 100, 400, 120))
ann.add_box(LabelledBBX(&quot;header&quot;, 0, 1, 10, 130, 400, 150))
ann.add_box(LabelledBBX(&quot;footer&quot;, 1, 1, 10, 800, 400, 820))
ann.add_box(LabelledBBX(&quot;footer&quot;, 2, 1, 10, 830, 400, 850))
ann.reduce()    # boxes that are close together are merged.
ann.save()      # save to file.
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
## Annotation data structure

Annotations are stored in layers. Each layer consists in annotation of the same class (as defined by `lib.classes.AnnotationClass`), 
made of labelled bounding boxes `lib.misc.bounding_box.LabelledBBX`.

Example: adding 4 boxes and merging boxes of the same group using `AnnotationLayer.reduce`.
```
ann = AnnotationLayer(location=&#34;/tmp/test.json&#34;)
ann.add_box(LabelledBBX(&#34;header&#34;, 0, 1, 10, 100, 400, 120))
ann.add_box(LabelledBBX(&#34;header&#34;, 0, 1, 10, 130, 400, 150))
ann.add_box(LabelledBBX(&#34;footer&#34;, 1, 1, 10, 800, 400, 820))
ann.add_box(LabelledBBX(&#34;footer&#34;, 2, 1, 10, 830, 400, 850))
ann.reduce()    # boxes that are close together are merged.
ann.save()      # save to file.
```
&#34;&#34;&#34;
from __future__ import annotations

import jsonpickle, bz2, shortuuid, lxml.etree as ET
from typing import Callable, Dict, Optional, List, Tuple
from rtree import index
from copy import copy


from .misc.bounding_box import LabelledBBX, BBX


class AnnotationLayer:
    &#34;&#34;&#34;
    The data structure for an annotation layer. It allows low level operations such as adding, moving, removing boxes 
    and high level operations such as filtering, mapping and reducing.
    It&#39;s important to note that it is not saved until `AnnotationLayer.save` is called.
    &#34;&#34;&#34;
    bbxs: Dict[str, LabelledBBX] 
    &#34;&#34;&#34;
    A map from randomized IDs to the bounding box instance.
    &#34;&#34;&#34;

    _dbs: Dict[int, index.Index]  # spatial index of boxes, by page
    _id_map: Dict[int, str]  # spatial index ID to box ID
    _map_id: Dict[str, int]  # box ID to spatial index ID
    _last_c: int

    def __init__(self, location: Optional[str] = None) -&gt; None:

        self.location = location
        if location is None:
            self.bbxs = {}
        else:
            try:
                with bz2.BZ2File(location + &#34;.bz2&#34;, &#34;r&#34;) as f:
                    self.bbxs = jsonpickle.decode(f.read().decode())
            except Exception as e:
                print(&#34;Loading failed:&#34;, str(e))
                self.bbxs = {}

        self._dbs = {}
        self._id_map = {}
        self._map_id = {}
        self._last_c = 0

        # construct spatial index
        for id, box in self.bbxs.items():
            if box.page_num not in self._dbs:
                self._dbs[box.page_num] = index.Index()
            self._dbs[box.page_num].insert(self._last_c, box.to_coor())
            self._id_map[self._last_c] = id
            self._map_id[id] = self._last_c
            self._last_c += 1

    def save(self, location: Optional[str] = None):
        &#34;&#34;&#34;
        Save layer to file.
        &#34;&#34;&#34;
        if self.location is None and location is None:
            raise Exception(&#34;No location given.&#34;)

        with bz2.BZ2File((self.location or location) + &#34;.bz2&#34;, &#34;w&#34;) as f:
            f.write(jsonpickle.encode(self.bbxs).encode())

    def __str__(self) -&gt; str:
        return &#34;\n&#34;.join([k + &#34;:&#34; + str(x) for k, x in self.bbxs.items()])

    def get_boxes(self) -&gt; Dict[str, LabelledBBX]:
        &#34;&#34;&#34;
        Get box as dictionnary
        &#34;&#34;&#34;
        return self.bbxs

    def add_box(self, box: LabelledBBX) -&gt; str:
        &#34;&#34;&#34;
        Add box to layer.
        &#34;&#34;&#34;
        uuid = shortuuid.uuid()
        self.bbxs[uuid] = box

        # update index
        if box.page_num not in self._dbs:
            self._dbs[box.page_num] = index.Index()
        self._dbs[box.page_num].insert(self._last_c, box.to_coor())
        self._id_map[self._last_c] = uuid
        self._map_id[uuid] = self._last_c
        self._last_c += 1

        return uuid

    def move_box(self, uuid: str, box: LabelledBBX):
        &#34;&#34;&#34;
        Move box in layer.
        &#34;&#34;&#34;
        # remove from index
        self._dbs[box.page_num].delete(self._map_id[uuid], self.bbxs[uuid].to_coor())

        self.bbxs[uuid] = box

        # update index
        self._dbs[box.page_num].add(self._map_id[uuid], box.to_coor())

    def delete_box(self, uuid: str):
        &#34;&#34;&#34;
        Delete box from layer.
        &#34;&#34;&#34;
        box = self.bbxs[uuid]
        box_spatial_id = self._map_id[uuid]
        # remove from index
        # print(&#34;delete: &#34;, self._map_id[uuid], box.to_coor())
        self._dbs[box.page_num].delete(self._map_id[uuid], box.to_coor())
        del self._id_map[box_spatial_id]
        del self._map_id[uuid]
        del self.bbxs[uuid]

    def get(self, target_box: BBX, mode: str = &#34;full&#34;) -&gt; Optional[BBX]:
        &#34;&#34;&#34;
        Get the box that either intersects or contain the `target_box`, according to `mode`.
        &#34;&#34;&#34;
        if mode not in [&#34;intersect&#34;, &#34;full&#34;]:
            raise Exception(f&#34;Unknown mode {mode}&#34;)

        if target_box.page_num not in self._dbs:
            return None

        def group_size(tgt_box):
            return sum(
                (
                    1
                    for box in self.bbxs.values()
                    if box.group == tgt_box.group and box.label == tgt_box.label
                )
            )

        min_box = None
        # min_val = float(&#39;inf&#39;)

        for index_id in self._dbs[target_box.page_num].intersection(
            target_box.to_coor()
        ):
            box = self.bbxs[self._id_map[index_id]]

            if mode == &#34;intersect&#34;:
                if box.intersects(target_box):  # and group_size(box) &lt; min_val:
                    # min_val = group_size(box)
                    min_box = box
            elif mode == &#34;full&#34;:
                if box.extend(10).contains(
                    target_box
                ):  # and group_size(box) &lt; min_val:
                    # min_val = group_size(box)
                    min_box = box

        return min_box

    def get_label(self, target_box: BBX, mode: str = &#34;full&#34;, default: str = &#34;O&#34;) -&gt; str:
        &#34;&#34;&#34;
        Get the label of the given box, or a default value. 
        &#34;&#34;&#34;
        box = self.get(target_box, mode)
        if box is None:
            return default
        else:
            return box.label

    def filter(self, predicate: Callable[[BBX], bool]):
        &#34;&#34;&#34;
        Keep boxes that are accepted by the predicate.
        &#34;&#34;&#34;
        to_filter = []
        for id, box in self.bbxs.items():
            if not predicate(box):
                to_filter.append(id)

        for id in to_filter:
            self.delete_box(id)

    def filter_map(self, f_mapper: Callable[[str, int], [str, int]]):
        &#34;&#34;&#34;
        Keep boxes that are accepted by the predicate and rename them. 
        &#34;&#34;&#34;
        to_filter = []
        for id, box in self.bbxs.items():
            new_info = f_mapper(box.label, box.group)
            if new_info is None:
                to_filter.append(id)
            else:
                box.label, box.group = new_info

        for id in to_filter:
            self.delete_box(id)

    def reduce(self) -&gt; AnnotationLayer:
        &#34;&#34;&#34;
        Reduce the number of bounding boxes by merging boxes of
        same category.
        &#34;&#34;&#34;
        print(&#34;number of boxes:&#34;, len(self.bbxs))
        # build a new layer
        new_layer = AnnotationLayer()

        # store a mapping box group -&gt; List of boxes composing that group
        by_group: Dict[Tuple[str, int], List[int]] = {}

        for box_id, box in self.bbxs.items():
            group_key = (box.label, box.group)
            if group_key not in by_group:
                by_group[group_key] = []

            by_group[group_key].append(self._map_id[box_id])

        # for each group, merge boxes.
        for ids in by_group.values():

            current_box = copy(self.bbxs[self._id_map[ids[0]]])

            for id in ids[1:]:
                # let&#39;s try to merge these two boxes.
                test_box = self.bbxs[self._id_map[id]]

                if (
                    current_box.page_num != test_box.page_num
                ):  # flush box as page changed.
                    new_layer.add_box(current_box)
                    current_box = copy(test_box)
                    continue

                # test merging the two boxes, checking if that doesn&#39;t intersect with another group.
                result_box, extensions_box = current_box.group_with(
                    test_box, inplace=False, extension=True
                )

                intersection = set()

                for extension_box in extensions_box:
                    intersection = intersection.union(
                        self._dbs[result_box.page_num].intersection(
                            extension_box.to_coor()
                        )
                    )

                if intersection.issubset(
                    ids
                ):  # it doesn&#39;t intersect with another group. we can merge the boxes.
                    current_box = result_box
                else:  # it does intersect: we flush current box.
                    new_layer.add_box(current_box)
                    current_box = copy(test_box)
            # flush last box
            new_layer.add_box(current_box)
        print(&#34;number of boxes in new layer:&#34;, len(new_layer.bbxs))
        return new_layer

    @staticmethod
    def from_pdf_annotations(pdf_annot: ET.ElementTree) -&gt; AnnotationLayer:
        &#34;&#34;&#34;
        Build the layer from the set of PDF annotations. 
        The label of the box corresponds to the link target.
        &#34;&#34;&#34;
        layer = AnnotationLayer()

        for annotation in pdf_annot.findall(&#34;.//ANNOTATION/ACTION[@type=&#39;uri&#39;]/..&#34;):
            dest = annotation.find(&#34;ACTION/DEST&#34;).text

            page_num = int(annotation.get(&#34;pagenum&#34;))

            quadpoints = annotation.findall(&#34;QUADPOINTS/QUADRILATERAL/POINT&#34;)
            min_h, min_v, max_h, max_v = None, None, None, None
            for point in quadpoints:
                h, v = float(point.get(&#34;HPOS&#34;)), float(point.get(&#34;VPOS&#34;))

                if min_h is None:
                    min_h, max_h = h, h
                    min_v, max_v = v, v
                else:
                    min_h = min(min_h, h)
                    max_h = max(max_h, h)
                    min_v = min(min_v, v)
                    max_v = max(max_v, v)
            box = BBX(page_num, min_h, min_v, max_h, max_v)
            layer.add_box(LabelledBBX.from_bbx(box, dest, 0))

        return layer</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.annotations.AnnotationLayer"><code class="flex name class">
<span>class <span class="ident">AnnotationLayer</span></span>
<span>(</span><span>location: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The data structure for an annotation layer. It allows low level operations such as adding, moving, removing boxes
and high level operations such as filtering, mapping and reducing.
It's important to note that it is not saved until <code><a title="lib.annotations.AnnotationLayer.save" href="#lib.annotations.AnnotationLayer.save">AnnotationLayer.save()</a></code> is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnotationLayer:
    &#34;&#34;&#34;
    The data structure for an annotation layer. It allows low level operations such as adding, moving, removing boxes 
    and high level operations such as filtering, mapping and reducing.
    It&#39;s important to note that it is not saved until `AnnotationLayer.save` is called.
    &#34;&#34;&#34;
    bbxs: Dict[str, LabelledBBX] 
    &#34;&#34;&#34;
    A map from randomized IDs to the bounding box instance.
    &#34;&#34;&#34;

    _dbs: Dict[int, index.Index]  # spatial index of boxes, by page
    _id_map: Dict[int, str]  # spatial index ID to box ID
    _map_id: Dict[str, int]  # box ID to spatial index ID
    _last_c: int

    def __init__(self, location: Optional[str] = None) -&gt; None:

        self.location = location
        if location is None:
            self.bbxs = {}
        else:
            try:
                with bz2.BZ2File(location + &#34;.bz2&#34;, &#34;r&#34;) as f:
                    self.bbxs = jsonpickle.decode(f.read().decode())
            except Exception as e:
                print(&#34;Loading failed:&#34;, str(e))
                self.bbxs = {}

        self._dbs = {}
        self._id_map = {}
        self._map_id = {}
        self._last_c = 0

        # construct spatial index
        for id, box in self.bbxs.items():
            if box.page_num not in self._dbs:
                self._dbs[box.page_num] = index.Index()
            self._dbs[box.page_num].insert(self._last_c, box.to_coor())
            self._id_map[self._last_c] = id
            self._map_id[id] = self._last_c
            self._last_c += 1

    def save(self, location: Optional[str] = None):
        &#34;&#34;&#34;
        Save layer to file.
        &#34;&#34;&#34;
        if self.location is None and location is None:
            raise Exception(&#34;No location given.&#34;)

        with bz2.BZ2File((self.location or location) + &#34;.bz2&#34;, &#34;w&#34;) as f:
            f.write(jsonpickle.encode(self.bbxs).encode())

    def __str__(self) -&gt; str:
        return &#34;\n&#34;.join([k + &#34;:&#34; + str(x) for k, x in self.bbxs.items()])

    def get_boxes(self) -&gt; Dict[str, LabelledBBX]:
        &#34;&#34;&#34;
        Get box as dictionnary
        &#34;&#34;&#34;
        return self.bbxs

    def add_box(self, box: LabelledBBX) -&gt; str:
        &#34;&#34;&#34;
        Add box to layer.
        &#34;&#34;&#34;
        uuid = shortuuid.uuid()
        self.bbxs[uuid] = box

        # update index
        if box.page_num not in self._dbs:
            self._dbs[box.page_num] = index.Index()
        self._dbs[box.page_num].insert(self._last_c, box.to_coor())
        self._id_map[self._last_c] = uuid
        self._map_id[uuid] = self._last_c
        self._last_c += 1

        return uuid

    def move_box(self, uuid: str, box: LabelledBBX):
        &#34;&#34;&#34;
        Move box in layer.
        &#34;&#34;&#34;
        # remove from index
        self._dbs[box.page_num].delete(self._map_id[uuid], self.bbxs[uuid].to_coor())

        self.bbxs[uuid] = box

        # update index
        self._dbs[box.page_num].add(self._map_id[uuid], box.to_coor())

    def delete_box(self, uuid: str):
        &#34;&#34;&#34;
        Delete box from layer.
        &#34;&#34;&#34;
        box = self.bbxs[uuid]
        box_spatial_id = self._map_id[uuid]
        # remove from index
        # print(&#34;delete: &#34;, self._map_id[uuid], box.to_coor())
        self._dbs[box.page_num].delete(self._map_id[uuid], box.to_coor())
        del self._id_map[box_spatial_id]
        del self._map_id[uuid]
        del self.bbxs[uuid]

    def get(self, target_box: BBX, mode: str = &#34;full&#34;) -&gt; Optional[BBX]:
        &#34;&#34;&#34;
        Get the box that either intersects or contain the `target_box`, according to `mode`.
        &#34;&#34;&#34;
        if mode not in [&#34;intersect&#34;, &#34;full&#34;]:
            raise Exception(f&#34;Unknown mode {mode}&#34;)

        if target_box.page_num not in self._dbs:
            return None

        def group_size(tgt_box):
            return sum(
                (
                    1
                    for box in self.bbxs.values()
                    if box.group == tgt_box.group and box.label == tgt_box.label
                )
            )

        min_box = None
        # min_val = float(&#39;inf&#39;)

        for index_id in self._dbs[target_box.page_num].intersection(
            target_box.to_coor()
        ):
            box = self.bbxs[self._id_map[index_id]]

            if mode == &#34;intersect&#34;:
                if box.intersects(target_box):  # and group_size(box) &lt; min_val:
                    # min_val = group_size(box)
                    min_box = box
            elif mode == &#34;full&#34;:
                if box.extend(10).contains(
                    target_box
                ):  # and group_size(box) &lt; min_val:
                    # min_val = group_size(box)
                    min_box = box

        return min_box

    def get_label(self, target_box: BBX, mode: str = &#34;full&#34;, default: str = &#34;O&#34;) -&gt; str:
        &#34;&#34;&#34;
        Get the label of the given box, or a default value. 
        &#34;&#34;&#34;
        box = self.get(target_box, mode)
        if box is None:
            return default
        else:
            return box.label

    def filter(self, predicate: Callable[[BBX], bool]):
        &#34;&#34;&#34;
        Keep boxes that are accepted by the predicate.
        &#34;&#34;&#34;
        to_filter = []
        for id, box in self.bbxs.items():
            if not predicate(box):
                to_filter.append(id)

        for id in to_filter:
            self.delete_box(id)

    def filter_map(self, f_mapper: Callable[[str, int], [str, int]]):
        &#34;&#34;&#34;
        Keep boxes that are accepted by the predicate and rename them. 
        &#34;&#34;&#34;
        to_filter = []
        for id, box in self.bbxs.items():
            new_info = f_mapper(box.label, box.group)
            if new_info is None:
                to_filter.append(id)
            else:
                box.label, box.group = new_info

        for id in to_filter:
            self.delete_box(id)

    def reduce(self) -&gt; AnnotationLayer:
        &#34;&#34;&#34;
        Reduce the number of bounding boxes by merging boxes of
        same category.
        &#34;&#34;&#34;
        print(&#34;number of boxes:&#34;, len(self.bbxs))
        # build a new layer
        new_layer = AnnotationLayer()

        # store a mapping box group -&gt; List of boxes composing that group
        by_group: Dict[Tuple[str, int], List[int]] = {}

        for box_id, box in self.bbxs.items():
            group_key = (box.label, box.group)
            if group_key not in by_group:
                by_group[group_key] = []

            by_group[group_key].append(self._map_id[box_id])

        # for each group, merge boxes.
        for ids in by_group.values():

            current_box = copy(self.bbxs[self._id_map[ids[0]]])

            for id in ids[1:]:
                # let&#39;s try to merge these two boxes.
                test_box = self.bbxs[self._id_map[id]]

                if (
                    current_box.page_num != test_box.page_num
                ):  # flush box as page changed.
                    new_layer.add_box(current_box)
                    current_box = copy(test_box)
                    continue

                # test merging the two boxes, checking if that doesn&#39;t intersect with another group.
                result_box, extensions_box = current_box.group_with(
                    test_box, inplace=False, extension=True
                )

                intersection = set()

                for extension_box in extensions_box:
                    intersection = intersection.union(
                        self._dbs[result_box.page_num].intersection(
                            extension_box.to_coor()
                        )
                    )

                if intersection.issubset(
                    ids
                ):  # it doesn&#39;t intersect with another group. we can merge the boxes.
                    current_box = result_box
                else:  # it does intersect: we flush current box.
                    new_layer.add_box(current_box)
                    current_box = copy(test_box)
            # flush last box
            new_layer.add_box(current_box)
        print(&#34;number of boxes in new layer:&#34;, len(new_layer.bbxs))
        return new_layer

    @staticmethod
    def from_pdf_annotations(pdf_annot: ET.ElementTree) -&gt; AnnotationLayer:
        &#34;&#34;&#34;
        Build the layer from the set of PDF annotations. 
        The label of the box corresponds to the link target.
        &#34;&#34;&#34;
        layer = AnnotationLayer()

        for annotation in pdf_annot.findall(&#34;.//ANNOTATION/ACTION[@type=&#39;uri&#39;]/..&#34;):
            dest = annotation.find(&#34;ACTION/DEST&#34;).text

            page_num = int(annotation.get(&#34;pagenum&#34;))

            quadpoints = annotation.findall(&#34;QUADPOINTS/QUADRILATERAL/POINT&#34;)
            min_h, min_v, max_h, max_v = None, None, None, None
            for point in quadpoints:
                h, v = float(point.get(&#34;HPOS&#34;)), float(point.get(&#34;VPOS&#34;))

                if min_h is None:
                    min_h, max_h = h, h
                    min_v, max_v = v, v
                else:
                    min_h = min(min_h, h)
                    max_h = max(max_h, h)
                    min_v = min(min_v, v)
                    max_v = max(max_v, v)
            box = BBX(page_num, min_h, min_v, max_h, max_v)
            layer.add_box(LabelledBBX.from_bbx(box, dest, 0))

        return layer</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.annotations.AnnotationLayer.bbxs"><code class="name">var <span class="ident">bbxs</span> : Dict[str, <a title="lib.misc.bounding_box.LabelledBBX" href="misc/bounding_box.html#lib.misc.bounding_box.LabelledBBX">LabelledBBX</a>]</code></dt>
<dd>
<div class="desc"><p>A map from randomized IDs to the bounding box instance.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.annotations.AnnotationLayer.from_pdf_annotations"><code class="name flex">
<span>def <span class="ident">from_pdf_annotations</span></span>(<span>pdf_annot: ET.ElementTree) ‑> <a title="lib.annotations.AnnotationLayer" href="#lib.annotations.AnnotationLayer">AnnotationLayer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build the layer from the set of PDF annotations.
The label of the box corresponds to the link target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pdf_annotations(pdf_annot: ET.ElementTree) -&gt; AnnotationLayer:
    &#34;&#34;&#34;
    Build the layer from the set of PDF annotations. 
    The label of the box corresponds to the link target.
    &#34;&#34;&#34;
    layer = AnnotationLayer()

    for annotation in pdf_annot.findall(&#34;.//ANNOTATION/ACTION[@type=&#39;uri&#39;]/..&#34;):
        dest = annotation.find(&#34;ACTION/DEST&#34;).text

        page_num = int(annotation.get(&#34;pagenum&#34;))

        quadpoints = annotation.findall(&#34;QUADPOINTS/QUADRILATERAL/POINT&#34;)
        min_h, min_v, max_h, max_v = None, None, None, None
        for point in quadpoints:
            h, v = float(point.get(&#34;HPOS&#34;)), float(point.get(&#34;VPOS&#34;))

            if min_h is None:
                min_h, max_h = h, h
                min_v, max_v = v, v
            else:
                min_h = min(min_h, h)
                max_h = max(max_h, h)
                min_v = min(min_v, v)
                max_v = max(max_v, v)
        box = BBX(page_num, min_h, min_v, max_h, max_v)
        layer.add_box(LabelledBBX.from_bbx(box, dest, 0))

    return layer</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lib.annotations.AnnotationLayer.add_box"><code class="name flex">
<span>def <span class="ident">add_box</span></span>(<span>self, box: LabelledBBX) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Add box to layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_box(self, box: LabelledBBX) -&gt; str:
    &#34;&#34;&#34;
    Add box to layer.
    &#34;&#34;&#34;
    uuid = shortuuid.uuid()
    self.bbxs[uuid] = box

    # update index
    if box.page_num not in self._dbs:
        self._dbs[box.page_num] = index.Index()
    self._dbs[box.page_num].insert(self._last_c, box.to_coor())
    self._id_map[self._last_c] = uuid
    self._map_id[uuid] = self._last_c
    self._last_c += 1

    return uuid</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.delete_box"><code class="name flex">
<span>def <span class="ident">delete_box</span></span>(<span>self, uuid: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete box from layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_box(self, uuid: str):
    &#34;&#34;&#34;
    Delete box from layer.
    &#34;&#34;&#34;
    box = self.bbxs[uuid]
    box_spatial_id = self._map_id[uuid]
    # remove from index
    # print(&#34;delete: &#34;, self._map_id[uuid], box.to_coor())
    self._dbs[box.page_num].delete(self._map_id[uuid], box.to_coor())
    del self._id_map[box_spatial_id]
    del self._map_id[uuid]
    del self.bbxs[uuid]</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate: Callable[[BBX], bool])</span>
</code></dt>
<dd>
<div class="desc"><p>Keep boxes that are accepted by the predicate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate: Callable[[BBX], bool]):
    &#34;&#34;&#34;
    Keep boxes that are accepted by the predicate.
    &#34;&#34;&#34;
    to_filter = []
    for id, box in self.bbxs.items():
        if not predicate(box):
            to_filter.append(id)

    for id in to_filter:
        self.delete_box(id)</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.filter_map"><code class="name flex">
<span>def <span class="ident">filter_map</span></span>(<span>self, f_mapper: Callable[[str, int], [str, int]])</span>
</code></dt>
<dd>
<div class="desc"><p>Keep boxes that are accepted by the predicate and rename them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_map(self, f_mapper: Callable[[str, int], [str, int]]):
    &#34;&#34;&#34;
    Keep boxes that are accepted by the predicate and rename them. 
    &#34;&#34;&#34;
    to_filter = []
    for id, box in self.bbxs.items():
        new_info = f_mapper(box.label, box.group)
        if new_info is None:
            to_filter.append(id)
        else:
            box.label, box.group = new_info

    for id in to_filter:
        self.delete_box(id)</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, target_box: BBX, mode: str = 'full') ‑> Union[<a title="lib.misc.bounding_box.BBX" href="misc/bounding_box.html#lib.misc.bounding_box.BBX">BBX</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the box that either intersects or contain the <code>target_box</code>, according to <code>mode</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, target_box: BBX, mode: str = &#34;full&#34;) -&gt; Optional[BBX]:
    &#34;&#34;&#34;
    Get the box that either intersects or contain the `target_box`, according to `mode`.
    &#34;&#34;&#34;
    if mode not in [&#34;intersect&#34;, &#34;full&#34;]:
        raise Exception(f&#34;Unknown mode {mode}&#34;)

    if target_box.page_num not in self._dbs:
        return None

    def group_size(tgt_box):
        return sum(
            (
                1
                for box in self.bbxs.values()
                if box.group == tgt_box.group and box.label == tgt_box.label
            )
        )

    min_box = None
    # min_val = float(&#39;inf&#39;)

    for index_id in self._dbs[target_box.page_num].intersection(
        target_box.to_coor()
    ):
        box = self.bbxs[self._id_map[index_id]]

        if mode == &#34;intersect&#34;:
            if box.intersects(target_box):  # and group_size(box) &lt; min_val:
                # min_val = group_size(box)
                min_box = box
        elif mode == &#34;full&#34;:
            if box.extend(10).contains(
                target_box
            ):  # and group_size(box) &lt; min_val:
                # min_val = group_size(box)
                min_box = box

    return min_box</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.get_boxes"><code class="name flex">
<span>def <span class="ident">get_boxes</span></span>(<span>self) ‑> Dict[str, <a title="lib.misc.bounding_box.LabelledBBX" href="misc/bounding_box.html#lib.misc.bounding_box.LabelledBBX">LabelledBBX</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get box as dictionnary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boxes(self) -&gt; Dict[str, LabelledBBX]:
    &#34;&#34;&#34;
    Get box as dictionnary
    &#34;&#34;&#34;
    return self.bbxs</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.get_label"><code class="name flex">
<span>def <span class="ident">get_label</span></span>(<span>self, target_box: BBX, mode: str = 'full', default: str = 'O') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the label of the given box, or a default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_label(self, target_box: BBX, mode: str = &#34;full&#34;, default: str = &#34;O&#34;) -&gt; str:
    &#34;&#34;&#34;
    Get the label of the given box, or a default value. 
    &#34;&#34;&#34;
    box = self.get(target_box, mode)
    if box is None:
        return default
    else:
        return box.label</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.move_box"><code class="name flex">
<span>def <span class="ident">move_box</span></span>(<span>self, uuid: str, box: LabelledBBX)</span>
</code></dt>
<dd>
<div class="desc"><p>Move box in layer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_box(self, uuid: str, box: LabelledBBX):
    &#34;&#34;&#34;
    Move box in layer.
    &#34;&#34;&#34;
    # remove from index
    self._dbs[box.page_num].delete(self._map_id[uuid], self.bbxs[uuid].to_coor())

    self.bbxs[uuid] = box

    # update index
    self._dbs[box.page_num].add(self._map_id[uuid], box.to_coor())</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self) ‑> <a title="lib.annotations.AnnotationLayer" href="#lib.annotations.AnnotationLayer">AnnotationLayer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Reduce the number of bounding boxes by merging boxes of
same category.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self) -&gt; AnnotationLayer:
    &#34;&#34;&#34;
    Reduce the number of bounding boxes by merging boxes of
    same category.
    &#34;&#34;&#34;
    print(&#34;number of boxes:&#34;, len(self.bbxs))
    # build a new layer
    new_layer = AnnotationLayer()

    # store a mapping box group -&gt; List of boxes composing that group
    by_group: Dict[Tuple[str, int], List[int]] = {}

    for box_id, box in self.bbxs.items():
        group_key = (box.label, box.group)
        if group_key not in by_group:
            by_group[group_key] = []

        by_group[group_key].append(self._map_id[box_id])

    # for each group, merge boxes.
    for ids in by_group.values():

        current_box = copy(self.bbxs[self._id_map[ids[0]]])

        for id in ids[1:]:
            # let&#39;s try to merge these two boxes.
            test_box = self.bbxs[self._id_map[id]]

            if (
                current_box.page_num != test_box.page_num
            ):  # flush box as page changed.
                new_layer.add_box(current_box)
                current_box = copy(test_box)
                continue

            # test merging the two boxes, checking if that doesn&#39;t intersect with another group.
            result_box, extensions_box = current_box.group_with(
                test_box, inplace=False, extension=True
            )

            intersection = set()

            for extension_box in extensions_box:
                intersection = intersection.union(
                    self._dbs[result_box.page_num].intersection(
                        extension_box.to_coor()
                    )
                )

            if intersection.issubset(
                ids
            ):  # it doesn&#39;t intersect with another group. we can merge the boxes.
                current_box = result_box
            else:  # it does intersect: we flush current box.
                new_layer.add_box(current_box)
                current_box = copy(test_box)
        # flush last box
        new_layer.add_box(current_box)
    print(&#34;number of boxes in new layer:&#34;, len(new_layer.bbxs))
    return new_layer</code></pre>
</details>
</dd>
<dt id="lib.annotations.AnnotationLayer.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, location: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save layer to file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, location: Optional[str] = None):
    &#34;&#34;&#34;
    Save layer to file.
    &#34;&#34;&#34;
    if self.location is None and location is None:
        raise Exception(&#34;No location given.&#34;)

    with bz2.BZ2File((self.location or location) + &#34;.bz2&#34;, &#34;w&#34;) as f:
        f.write(jsonpickle.encode(self.bbxs).encode())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#annotation-data-structure">Annotation data structure</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib" href="index.html">lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.annotations.AnnotationLayer" href="#lib.annotations.AnnotationLayer">AnnotationLayer</a></code></h4>
<ul class="">
<li><code><a title="lib.annotations.AnnotationLayer.add_box" href="#lib.annotations.AnnotationLayer.add_box">add_box</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.bbxs" href="#lib.annotations.AnnotationLayer.bbxs">bbxs</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.delete_box" href="#lib.annotations.AnnotationLayer.delete_box">delete_box</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.filter" href="#lib.annotations.AnnotationLayer.filter">filter</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.filter_map" href="#lib.annotations.AnnotationLayer.filter_map">filter_map</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.from_pdf_annotations" href="#lib.annotations.AnnotationLayer.from_pdf_annotations">from_pdf_annotations</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.get" href="#lib.annotations.AnnotationLayer.get">get</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.get_boxes" href="#lib.annotations.AnnotationLayer.get_boxes">get_boxes</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.get_label" href="#lib.annotations.AnnotationLayer.get_label">get_label</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.move_box" href="#lib.annotations.AnnotationLayer.move_box">move_box</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.reduce" href="#lib.annotations.AnnotationLayer.reduce">reduce</a></code></li>
<li><code><a title="lib.annotations.AnnotationLayer.save" href="#lib.annotations.AnnotationLayer.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>